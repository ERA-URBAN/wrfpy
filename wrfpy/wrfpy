#!/usr/bin/env python

'''
description:    Configuration part of wrfpy
license:        APACHE 2.0
author:         Ronald van Haren, NLeSC (r.vanharen@esciencecenter.nl)
'''

from wrfpy.config import config
from wrfpy import utils
import os
import argparse

class wrfpy(config):
  def __init__(self):
    results = self._cli_parser()
    global logger
    logger = utils.start_logging(os.path.join(os.path.expanduser("~"),
                                              'wrfpy.log'))
    if results['init']:
      self._create_directory_structure(results['suitename'],
                                        results['basedir'])
    elif results['create']:
      self._create_cylc_config(results['suitename'],
                               results['basedir'])


  def _cli_parser(self):
    '''
    parse command line arguments
    '''
    parser = argparse.ArgumentParser(
      description='WRFpy',
      formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--init', action='store_true',
                        help='Initialize suite')
    parser.add_argument('--create', action='store_true',
                        help='Create suite config')
    parser.add_argument('--basedir', type=str,
                        default=os.path.join(os.path.expanduser("~"),
                        'cylc-suites'),
                        help="basedir in which suites are installed")
    parser.add_argument('--suitename', type=str, required=True,
                         help='name')
    results = vars(parser.parse_args())
    # either initialize or create a suite, not both
    if (results['init'] ^ results['create']):
      return results
    else:
      # print error message to the user, combiniation of --init and --create
      # is not allowed
      print("Only one of '--init' and '--create' is allowed.")
      exit()


  def _create_directory_structure(self, suitename, basedir=None):
    '''
    Create directory structure for the Cylc configuration
    '''
    # set basedir to users home directory if not supplied
    if not basedir:
      basedir = os.path.join(os.path.expanduser("~"), 'cylc-suites')
    # subdirectories to create
    subdirs = ['bin' , 'control', 'doc', 'inc']
    # create subdirectories
    [utils._create_directory(
     os.path.join(basedir, suitename, subdir))
     for subdir in subdirs]
    # create empty json config file in suite directory
    # this does not overwrite an existing config file
    config.__init__(self, os.path.join(
                    basedir, suitename, 'config.json'))


  def _create_cylc_config(self, suitename, basedir):
    '''
    Create cylc suite.rc configuration file based on config.json
    '''
    config.__init__(self, os.path.join(
                    basedir, suitename, 'config.json'))
    self.incr_hour = self.config['options_general']['run_hours']
    suiterc = self._header()
    suiterc += self._scheduling()
    suiterc += self._runtime()
    suiterc += self._visualization()
    self._write(suiterc, os.path.join(basedir, suitename, 'suite.rc'))


  def _header(self):
    '''
    define suite.rc header information
    '''
    start_time = utils.datetime_to_string(
      utils.return_validate(self.config['options_general']['date_start']),
      format='%Y%m%d%H')
    end_time = utils.datetime_to_string(
      utils.return_validate(self.config['options_general']['date_end']),
      format='%Y%m%d%H')
    # define template
    template = """#!Jinja2

{{% set START = "{start_time}" %}}
{{% set STOP  = "{end_time}" %}}

[cylc]
  # set required cylce point format
  cycle point format = %Y%m%d%H

"""
    # context variables in template
    context = {
      "start_time":start_time,
      "end_time":end_time
      }
    return template.format(**context)

  def _scheduling(self):
    '''
    define suite.rc scheduling information
    '''
    # get start_hour and increment time from config.json
    start_hour = str(
      utils.return_validate(
      self.config['options_general']['date_start']).hour).zfill(2)
    # define template
    template = """[scheduling]
  initial cycle point = {{{{ START }}}}
  final cycle time   = {{{{ STOP }}}}
  [[dependencies]]
    # Initial cycle point
    [[[R1/T{start_hour}]]]
      graph = \"\"\"
        init => wrf_real => wrfda => wrf_run
        init => obsproc_run
        obsproc_run => wrfda
      \"\"\"
    # Repeat every {incr_hour} hours, starting {incr_hour} hours after initial cylce point
    [[[+PT{incr_hour}H/PT{incr_hour}H]]]
      graph = \"\"\"
        wrf_run[-PT{incr_hour}H] => init => wrf_real => wrfda => wrf_run
        init => obsproc_run
        obsproc_run => wrfda
      \"\"\"

"""
    # context variables in template
    context = {
      "start_hour": start_hour,
      "incr_hour": self.incr_hour
      }
    return template.format(**context)


  def _runtime(self):
    '''
    define suite.rc runtime information
    '''
    return (self._runtime_base() + self._runtime_init() + self._runtime_real() +
            self._runtime_wrf() + self._runtime_obsproc() +
            self._runtime_wrfda() + self._runtime_upp())


  def _runtime_base(self):
    '''
    define suite.rc runtime information: base
    '''
    # define template
    template = """[runtime]
  [[root]] # suite defaults
    [[[job submission]]]
      method = background
"""
    # context variables in template
    context = {}
    return template.format(**context)


  def _runtime_init(self):
    '''
    define suite.rc runtime information: init
    '''
    init_command = """#!/usr/bin/env python
import wrfpy.utils as utils
from wrfpy.wrf import run_wrf
import wrfpy.wrfda as wrfda
import os
dt = utils.convert_cylc_time(os.environ('$CYLC_TASK_CYCLE_POINT'))
incr_hour = self.config['options_general']['run_hours']
run_wrf(dt, dt + datetime.timedelta(hours={incr_hour}))
WRFDA = wrfda()  # initialize object
WRFDA.obsproc_init(datestart)

"""
    init_context = {
      "incr_hour": self.incr_hour
      }
    init = init_command.format(**init_context)
    # define template
    template = """
  [[init]]
    script = \"\"\"
{wrf_init}
\"\"\"
"""
    # context variables in template
    context = {
      "wrf_init": wrf_init,
      "obsproc_init":  obsproc_init
      }
    return template.format(**context)


  def _runtime_real(self):
    '''
    define suite.rc runtime information: real.exe
    '''
    # define template
    template = """
  [[wrf_real]]
    script = \"\"\"
{command}
\"\"\"
    [[[environment]]]
      WORKDIR = {wrf_run_dir}
      CYLC_TASK_WORK_DIR = $WORKDIR
    [[[job submission]]]
      method = {method}
    [[[directives]]]
      {directives}
"""
    try:
      if self.config['options_slurm']['slurm_real.exe']:
        method = "slurm"
        command="""#!/usr/bin/env bash
if [ -n "$SLURM_CPUS_PER_TASK" ]; then
  omp_threads=$SLURM_CPUS_PER_TASK
else
  omp_threads=1
fi
export OMP_NUM_THREADS=$omp_threads
srun ./real.exe"""
        with open(self.config['options_slurm']['slurm_real.exe'], 'r') as myfile:
          directives=myfile.read().replace('\n', '\n      ')
      else:
          method = "background"
          command="""#!/usr/bin/env bash
./real.exe"""
          directives=""
    except KeyError:
      # slurm_real.exe not found in config.json, default to background
      method = "background"
      command="""#!/usr/bin/env bash
./real.exe"""
      directives=""
    # context variables in template
    context = {
      "command": command,
      "wrf_run_dir": self.config['filesystem']['wrf_run_dir'],
      "method": method,
      "directives": directives
      }
    return template.format(**context)


  def _runtime_wrf(self):
    '''
    define suite.rc runtime information: wrf.exe
    '''
    # define template
    template = """
  [[wrf_run]]
    script = \"\"\"
{command}
\"\"\"
    [[[environment]]]
      WORKDIR = {wrf_run_dir}
      CYLC_TASK_WORK_DIR = $WORKDIR
    [[[job submission]]]
      method = {method}
    [[[directives]]]
      {directives}
"""
    try:
      if self.config['options_slurm']['slurm_wrf.exe']:
        method = "slurm"
        command = """#!/usr/bin/env bash
if [ -n "$SLURM_CPUS_PER_TASK" ]; then
  omp_threads=$SLURM_CPUS_PER_TASK
else
  omp_threads=1
fi
export OMP_NUM_THREADS=$omp_threads
srun ./wrf.exe"""
        with open(self.config['options_slurm']['slurm_wrf.exe'], 'r') as myfile:
          directives=myfile.read().replace('\n', '\n      ')
      else:
          method = "background"
          directives=""
          command = """#!/usr/bin/env bash
./wrf.exe"""
    except KeyError:
      # slurm_real.exe not found in config.json, default to background
      method = "background"
      directives=""
      command = """#!/usr/bin/env bash
./wrf.exe"""
    # context variables in template
    context = {
      "command": command,
      "wrf_run_dir": self.config['filesystem']['wrf_run_dir'],
      "method": method,
      "directives": directives
      }
    return template.format(**context)


  def _runtime_obsproc(self):
    '''
    define suite.rc runtime information: obsproc.exe
    '''
    # define template
    template = """
  [[obsproc_run]]
    script = \"\"\"
{command}
\"\"\"
    [[[environment]]]
      WORKDIR = {obsproc_dir}
      CYLC_TASK_WORK_DIR = $WORKDIR
    [[[job submission]]]
      method = {method}
    [[[directives]]]
      {directives}
"""
    try:
      if self.config['options_slurm']['slurm_obsproc.exe']:
        method="slurm"
        command="""#!/usr/bin/env bash
srun ./obsproc.exe"""
        with open(self.config[
                  'options_slurm']['slurm_obsproc.exe'], 'r') as myfile:
          directives=myfile.read().replace('\n', '\n      ')
      else:
          method = "background"
          command="""#!/usr/bin/env bash
./obsproc.exe"""
          directives=""
    except KeyError:
      # slurm_real.exe not found in config.json, default to background
      method = "background"
      command="""#!/usr/bin/env bash
./obsproc.exe"""
      directives=""
    # context variables in template
    context = {
      "command": command,
      "obsproc_dir": os.path.join(self.config['filesystem']['work_dir'], 'obsproc'),
      "method": method,
      "directives": directives
      }
    return template.format(**context)


  def _runtime_wrfda(self):
    '''
    define suite.rc runtime information: wrfda
    '''
    # define template
    template = """
  [[wrfda]]
    script = \"\"\"
{command}
\"\"\"
    [[[environment]]]
      CYLC_TASK_WORK_DIR = $WORKDIR
    [[[job submission]]]
      method = {method}
    [[[directives]]]
      {directives}
"""
    command="""#!/usr/bin/env python
import wrfpy.utils as utils
from wrfpy.wrfda import wrfda
import os
dt = utils.convert_cylc_time(os.environ('CYLC_TASK_CYCLE_POINT'))
WRFDA = wrfda()  # initialize object
WRFDA.prepare_updatebc(dt)
for domain in range(1, WRFDA.max_dom+1):
  WRFDA.updatebc_run(domain)  # run da_updatebc.exe
WRFDA.prepare_wrfda()  # prepare for running da_wrfvar.exe
for domain in range(1, WRFDA.max_dom+1):
  WRFDA.wrfvar_run(domain)  # run da_wrfvar.exe
WRFDA.prepare_updatebc_type('lateral', dt, 1)  # prepare for updating lateral bc
WRFDA.updatebc_run(1)  # run da_updatebc.exe
WRFDA.wrfda_post()  # copy files over to WRF run_dir"""
    try:
      if self.config['options_slurm']['slurm_da_wrfvar.exe']:
        method="slurm"
        with open(self.config[
                  'options_slurm']['slurm_da_wrfvar.exe'], 'r') as myfile:
          directives=myfile.read().replace('\n', '\n      ')
      else:
          method = "background"
          directives=""
    except KeyError:
      # slurm_real.exe not found in config.json, default to background
      method = "background"
      directives=""
    # context variables in template
    context = {
      "command": command,
      "method": method,
      "directives": directives
      }
    return template.format(**context)

  def _runtime_upp(self):
    '''
    define suite.rc runtime information: wrfda
    '''
    # define template
    template = """
  [[upp]]
    script = \"\"\"
{command}
\"\"\"
    [[[environment]]]
    [[[job submission]]]
      method = background
    [[[directives]]]
      {directives}
"""
    command="""#!/usr/bin/env python
import wrfpy.upp as upp
import wrfpy.utils as utils
import os
postprocess = upp()
# get datetime object for currenct cycle point
dt = utils.convert_cylc_time(os.environ('CYLC_TASK_CYCLE_POINT'))
# construct wrfout name for domain 1
dt_str = dt.strftime('%Y-%m-%d_%H:%M:%S')
wrfout_name = wrfout_d01_ + dt_str
wrfout_file = os.path.join(self.config['filesystem']['wrf_run_dir'], wrfout_name)
start_date = utils.return_validate(postprocess.config['options_general']['date_start'])
if (start_date == dt):  # very first timestep
  postprocess.run_unipost_file(wrfout_files[0], use_t0=True)
else:
  postprocess.run_unipost_file(wrfout_files[0], use_t0=False)"""
    context = {
      "command": command,
      }
    return template.format(**context)

  def _visualization(self):
    '''
    define suite.rc visualization information
    '''
    # define template
    template = """
[visualization]
  initial cycle point = {{ START }}
  final cycle time   = {{ STOP }}
  default node attributes = "style=filled", "fillcolor=grey"
"""
    return template


  def _write(self, suiterc, filename):
    '''
    write cylc suite.rc config to file
    '''
    # create the itag file and write content to it based on the template
    try:
      with open(filename, 'w') as itag:
        itag.write(suiterc)
    except IOError as e:
      #logger.error('Unable to write itag file: %s' %filename)
      raise  # re-raise exception
    #logger.debug('Leave write_itag')


if __name__ == "__main__":
  wrfpy()

